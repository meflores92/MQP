/*
 ============================================================================
 Name        : rx_testing
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : Receive signal with USRP and save to file for post processing in MATLAB
 ============================================================================
 */

//Includes 
#include <uhd.h>
#include "getopt.h"
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <complex.h>

//Function Declaration
int create_args();
int init_usrp();
int stream_rx();
int terminate();

//Global Variables
bool stop_signal_called = false;
int option = 0;
double freq = 3619200000;
double rate = 46.08e6;
double gain = 70.0;
double bandwidth = 40.00e6; //Default for B210 == 56.00Mhz
char* device_args = "serial=3164073, num_recv_frames = 512, recv_frame_size = 7680"; //originally null
size_t channel = 0;
char* filename = "/home/tornado/Desktop/rx_testing/out.dat";
size_t n_samples = 40080000;
bool verbose = true;
int return_code = EXIT_SUCCESS;
bool custom_filename = false;
char error_string[512];
char mboard_name[512];
uhd_rx_streamer_handle rx_streamer;
uhd_usrp_handle usrp;
uhd_rx_metadata_handle md;
size_t mboard = 0;
char *clk_string = "external";
char time_source_out[512];
size_t num_mboards_out;
char *time_string = "external";
char clock_source_out[512];
double bandwidth_out;
size_t samps_per_buff;
double complex *buff = NULL;
void **buffs_ptr = NULL;
FILE *fp = NULL;
size_t num_acc_samps = 0;

//Signal Handler (For Control + C termination)
void sigint_handler(int code){
	(void)code;
	stop_signal_called = true;
}

//Set-up USRP Parameters
int create_args() {
	if (!device_args)
	device_args = strdup("");

	// Create USRP
	fprintf(stderr, "Creating USRP with args \"%s\"...\n", device_args);
    uhd_usrp_make(&usrp, device_args);

	// Create RX streamer
	uhd_rx_streamer_make(&rx_streamer);

	// Create RX metadata
	uhd_rx_metadata_make(&md);

	// Create other necessary structs
	uhd_tune_request_t tune_request = {
			.target_freq = freq,
			.rf_freq_policy = UHD_TUNE_REQUEST_POLICY_AUTO,
			.dsp_freq_policy = UHD_TUNE_REQUEST_POLICY_AUTO,
	};
	uhd_tune_result_t tune_result;

	uhd_stream_args_t stream_args = {
			.cpu_format = "fc64",
			.otw_format = "sc16",
			.args = "spp= 1916", //1916
			.channel_list = &channel,
			.n_channels = 1
	};

	uhd_stream_cmd_t stream_cmd = {
			.stream_mode = UHD_STREAM_MODE_START_CONTINUOUS,
			//.num_samps = n_samples,
			.stream_now = true
	};

	uhd_stream_cmd_t stream_cmd_term = {
			.stream_mode = UHD_STREAM_MODE_STOP_CONTINUOUS,
			//.num_samps = n_samples,
			.stream_now = true
			//.time_spec_full_secs = 1
	};

	//	uhd_stream_cmd_t stream_cmd = {
	//				.stream_mode = UHD_STREAM_MODE_NUM_SAMPS_AND_DONE,
	//				.num_samps = n_samples,
	//				.stream_now = true
	//		};

    return EXIT_SUCCESS;
}

//Initialize USRP Clock Source, Sample Rate, Gain, etc. 
int init_usrp(){
    //Check Number of Motherboards
	fprintf(stderr, "Checking Number of Motherboards\n");
	uhd_usrp_get_num_mboards(usrp, &num_mboards_out);
	fprintf(stderr, "	Number of Motherboards: %d\n", (int)num_mboards_out);

	//Check Motherboard Name
	fprintf(stderr, "Checking Motherboard Name\n");
	uhd_usrp_get_mboard_name(usrp, mboard, mboard_name, 512)
	fprintf(stderr, "	Motherboard name: %s\n", mboard_name);

	//Set Clock Source External
	fprintf(stderr, "Setting Clock Source\n");
	uhd_usrp_set_clock_source(usrp, clk_string, mboard);

    // Check Clock source
	fprintf(stderr, "Checking Clock Source\n");
	uhd_usrp_get_clock_source(usrp, 0, clock_source_out, 512);
	fprintf(stderr, "	Clock Source: %s\n", clock_source_out);

	//Set Time Source External
	fprintf(stderr, "Setting Time Source\n");
	uhd_usrp_set_time_source(usrp, time_string, mboard);

    // Check Time source
	fprintf(stderr, "Checking Time Source\n");
	uhd_usrp_get_time_source(usrp, 0, time_source_out, 512);
	fprintf(stderr, "	Time Source: %s\n", time_source_out);

	//Check to see if External Reference Locked
	if (check_ref_locked(usrp, mboard)) {
		fprintf(stderr, "USRP locked to external reference!\n");
	} else {
		fprintf(stderr, "Failed to lock to external reference. Exiting.\n");
		exit(EXIT_FAILURE);
	}

	// Set rate
	fprintf(stderr, "Setting RX Rate: %f...\n", rate);
	uhd_usrp_set_rx_rate(usrp, rate, channel);

	// See what rate actually is
	uhd_usrp_get_rx_rate(usrp, channel, &rate);
	fprintf(stderr, "	Actual RX Rate: %f...\n", rate);

	// Set gain
	fprintf(stderr, "Setting RX Gain: %f dB...\n", gain);
	uhd_usrp_set_rx_gain(usrp, gain, channel, "");

	// See what gain actually is
	uhd_usrp_get_rx_gain(usrp, channel, "", &gain);
	fprintf(stderr, "	Actual RX Gain: %f...\n", gain);

	// Set frequency
	fprintf(stderr, "Setting RX frequency: %f MHz...\n", freq/1e6);
	uhd_usrp_set_rx_freq(usrp, &tune_request, channel, &tune_result);

	// See what frequency actually is
	uhd_usrp_get_rx_freq(usrp, channel, &freq);
	fprintf(stderr, "	Actual RX frequency: %f MHz...\n", freq / 1e6);

	// Set RX Bandwidth
	fprintf(stderr, "Setting RX Bandwidth: %f MHz\n", bandwidth/1e6);
	uhd_usrp_set_rx_bandwidth(usrp, bandwidth, channel);

	// See what RX Bandwidth is
	fprintf(stderr, "Checking RX Bandwidth...\n");
	uhd_usrp_get_rx_bandwidth(usrp, channel, &bandwidth_out);
	fprintf(stderr, "	Actual RX Bandwidth: %f MHz\n", bandwidth_out / 1e6);

	// Set up streamer
	stream_args.channel_list = &channel;
	uhd_usrp_get_rx_stream(usrp, &stream_args, rx_streamer);

	// Set up buffer
	uhd_rx_streamer_max_num_samps(rx_streamer, &samps_per_buff);
	fprintf(stderr, "Buffer size in samples: %zu\n", samps_per_buff);
	buff = malloc(samps_per_buff * 2 * sizeof(double));
	buffs_ptr = (void**)&buff;

    return EXIT_SUCCESS;
}

//Streaming Function
int stream_rx(){
	// Issue stream command
	fprintf(stderr, "Issuing stream command.\n");
	uhd_rx_streamer_issue_stream_cmd(rx_streamer, &stream_cmd);

	// Set up file output
	fp = fopen(filename, "wb");

	uhd_rx_metadata_error_code_t error_code;
	signal(SIGINT, &sigint_handler);
	fprintf(stderr, "Press Ctrl+C to stop streaming...\n");

	// Actual streaming
	while (num_acc_samps< n_samples) {
		size_t num_rx_samps = 0;
		if (stop_signal_called) break;
		uhd_rx_streamer_recv(rx_streamer, buffs_ptr, samps_per_buff, &md, 0.1, false, &num_rx_samps); // Default: one_packet = false

		uhd_rx_metadata_error_code(md, &error_code);

		if(error_code != UHD_RX_METADATA_ERROR_CODE_NONE){
			fprintf(stderr, "Error code 0x%x was returned during streaming. Aborting.\n", error_code);

			int64_t full_secs;
			double frac_secs;
			uhd_rx_metadata_time_spec(md, &full_secs, &frac_secs);
			fprintf(stderr, "Received packet: %zu samples, %.f full secs, %f frac secs\n",
					num_rx_samps,
					difftime(full_secs, (int64_t) 0),
					frac_secs);
			break;
		}

		// Handle data
		//fwrite(buff, sizeof(double) * 2, num_rx_samps, fp);
		//printf("Data 0: %f, Data 1: %f\n", buff[0], buff[1]);
		//		if (verbose) {
		//			int64_t full_secs;
		//			double frac_secs;
		//			uhd_rx_metadata_time_spec(md, &full_secs, &frac_secs);
		//			fprintf(stderr, "Received packet: %zu samples, %.f full secs, %f frac secs\n",
		//					num_rx_samps,
		//					difftime(full_secs, (int64_t) 0),
		//					frac_secs);
		//		}

		num_acc_samps += num_rx_samps;
	}
}

int terminate(){
	fprintf(stderr, "Issuing stop stream command.\n");
    uhd_rx_streamer_issue_stream_cmd(rx_streamer, &stream_cmd_term);

	printf("First Index of Last Buffer: Real: %f, Imag: %f\n", creal(buff[0]),cimag(buff[0]));
	printf("Second Index of Last Buffer: Real: %f, Imag: %f\n", creal(buff[1]),cimag(buff[1]));

	int64_t full_secs;
	double frac_secs;
	uhd_rx_metadata_time_spec(md, &full_secs, &frac_secs);
	fprintf(stderr, "Execution Time: %.f full secs, %f frac secs\n",
			difftime(full_secs, (int64_t) 0),
			frac_secs);

	// Cleanup
	fclose(fp);

	if(buff){
		if(verbose){
			fprintf(stderr, "Freeing buffer.\n");
		}
		free(buff);
	}
	buff = NULL;
	buffs_ptr = NULL;

	if(verbose){
		fprintf(stderr, "Cleaning up RX streamer.\n");
	}
	uhd_rx_streamer_free(&rx_streamer);

	if(verbose){
		fprintf(stderr, "Cleaning up RX metadata.\n");
	}
	uhd_rx_metadata_free(&md);

	if(verbose){
		fprintf(stderr, "Cleaning up USRP.\n");
	}
	if(return_code != EXIT_SUCCESS && usrp != NULL){
		uhd_usrp_last_error(usrp, error_string, 512);
		fprintf(stderr, "USRP reported the following error: %s\n", error_string);
	}
	uhd_usrp_free(&usrp);

	if(custom_filename){
		free(filename);
		puts("reached 5");
	}

	fprintf(stderr, (return_code ? "Failure\n" : "Success\n"));
	return return_code;
}

//Function to Check External Reference Lock
int check_ref_locked(uhd_usrp_handle usrp, size_t mboard) {
	bool ref_locked = false;
	uhd_sensor_value_handle sensor_value;
	uhd_sensor_value_data_type_t data_type_out = "UHD_SENSOR_VALUE_BOOLEAN";

	uhd_sensor_value_data_type(sensor_value, &data_type_out);

	//Get sensor names
	extern C {
		bool check_for_sensor(size_t mboad){
			string sensor_names = usrp->get_mboard_sensor_names(mboard);
			return std::find(sensor_names.begin(), sensor_names.end(), "ref_locked") != sensor_names.end();
		}
	}

	if(check_for_sensor(mboard)) {
		fprintf(stderr, "Waiting for reference lock...");

		for (int i = 0; i < 30 && (~ref_locked); i++) {
			//Original C++ ... ref_locked = s->usrp->get_mboard_sensor("ref_locked", mboard).to_bool();

			uhd_usrp_get_mboard_sensor(usrp, "ref_locked", mboard, &sensor_value);
			ref_locked = sensor_value;

			if (~ref_locked) {
				fprintf(stderr, "...\n");
			}
		}

		if(ref_locked) {
			fprintf(stderr, "LOCKED\n");
		}
		else {
			fprintf(stderr, "FAILED\n");
		}
	}
	else {
		fprintf(stderr, "ref_locked sensor not present on this board.\n");
	}

	return ref_locked;
}
